---
title: Docker Alpine镜像编译go可执行程序
date: "2019-04-27"
categories: ["docker"]
tags: ["docker", "go"]
---

我们刚接触Docker时，最常见的入门方式是使用Ubuntu或Debian等系统构建虚拟机，这种方式的弊端是产生的镜像太大了，单单是Ubuntu的基础镜像就已经有187.9MB，而且大部分装好的软件和依赖库都不会用到。

容器和虚拟机的主要区别在于，容器在宿主系统的一个隔离进程空间里边运行，因此它不需要有独立的内核和其他系统文件，只要在上边安装你需要使用的东西，我们会需要Python来运行Go的服务吗？这不是一个很难回答的问题。

# 微基础镜像
首先我们要抛弃使用Ubuntu或者Debian作为基础镜像这种思路，我们着眼于更轻量的选择。

Alpine Linux是一个微型的Linux分发版，可以用来构建一个体积只有5M的基容器，它是基于一个嵌入式系统BusyBox改造的。那为什么不直接用BusyBox呢？使用Alpine有几个优点，首先，Alpine上有一个包管理系统apk，使用它可以简化容器的维护；第二，Alpine的内核已经被打上PaX补丁，可以免受大量0 day漏洞的侵害。

# 为Alpine Linux编译Go应用
使用Go来构建微服务的一个优点是，它会被编译成二进制包，这样的话，它就不需要框架或者运行依赖，这样非常有利，因为正如前面所说Alpine是一个非常轻量级的分发版，并不是所有C语言依赖库都有安装，所以Go的动态库依赖很可能也没有。

因此在linux平台编译的go二进制程序打包进alpine可能会出现错误，解决这个问题的方法是:

1. 忽略cgo并且只是用静态链接
2. 强制编译所有包和可执行程序

例如：

```shell
 export CGO_ENABLED = 0

go build -a -x -ldflags "-s -w" -gcflags "-l" .
```

这样编译好的二进制文件就可以直接打包进去